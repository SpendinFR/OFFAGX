{
  "desc_type": "module_emit",
  "name": "skill_pattern_learner",
  "code": "import os, json, time, re\nPATH = 'mem/skill_patterns.json'\n\ndef _load():\n    if not os.path.exists(PATH):\n        return []\n    with open(PATH, 'r', encoding='utf-8') as f:\n        return json.load(f)\n\ndef _save(pats):\n    os.makedirs('mem', exist_ok=True)\n    with open(PATH, 'w', encoding='utf-8') as f:\n        json.dump(pats, f, ensure_ascii=False, indent=2)\n\n\ndef run(ctx=None):\n    ctx = ctx or {}\n    if ctx.get('desc_type') != 'skill_build_plan':\n        return {'desc_type': 'skill_pattern_learner_skip', 'ts': time.time()}\n    if ctx.get('source') != 'llm':\n        return {'desc_type': 'skill_pattern_learner_skip', 'reason': 'not_from_llm', 'ts': time.time()}\n    task = ctx.get('task_text') or ''\n    skill_id = ctx.get('skill_id') or 'skill_unknown'\n    deps = ctx.get('deps') or []\n    pats = _load()\n    kw = [w for w in task.lower().split()[:4] if w]\n    if not kw:\n        return {'desc_type': 'skill_pattern_learner_skip', 'reason': 'no_kw', 'ts': time.time()}\n    re_pat = r'(' + r'|'.join(re.escape(k) for k in kw) + r')'\n    for p in pats:\n        if p.get('name') == skill_id:\n            return {'desc_type': 'skill_pattern_learner_skip', 'reason': 'already', 'ts': time.time()}\n    pats.append({'name': skill_id, 're': re_pat, 'deps': deps, 'learned_ts': time.time()})\n    _save(pats)\n    return {'desc_type': 'skill_pattern_learned', 'pattern': {'re': re_pat, 'deps': deps}, 'ts': time.time()}\n"
}
