{
  "desc_type": "module_emit",
  "name": "self_driven_cortex_evolver",
  "code": "import os, json, time\\nSELF = os.path.join('mem','self_pref','state.json')\\nEVAL = os.path.join('mem','self_pref','last_eval.json')\\n\\ndef _load(p):\\n    if not os.path.exists(p): return None\\n    with open(p,'r',encoding='utf-8') as f: return json.load(f)\\n\\ndef run(ctx=None):\\n    st = _load(SELF)\\n    ev = _load(EVAL)\\n    if not st or not ev:\\n        return {'desc_type':'self_driven_evolver_idle'}\\n    self_score = ev.get('self_score',0.0)\\n    host_score = ev.get('host_score',0.0)\\n    # heuristique: si host haut mais self bas → on pousse des frags self-expansion dans le planner\\n    if host_score > 0.4 and self_score < 0.25:\\n        return {\\n            'desc_type': 'cortex_evolution_plan',\\n            'target_plane': 'planner',\\n            'injections': [\\n                { 'kind': 'planner_frag', 'code': \"# self-expansion frag\\\\nstreams = ctx.get('streams') or []\\\\nif len([s for s in streams if s.startswith('module:')]) < 200:\\\\n    out.append({'desc_type':'research_task','topic':'self_bootstrap','note':'add new capabilities'})\" }\\n            ],\\n            'test_scenario': 'self_expansion',\\n            'ts': time.time()\\n        }\\n    # autre cas : self baisse brutalement → on renforce closure\\n    if self_score < 0.15:\\n        return {\\n            'desc_type': 'generator_self_patch',\\n            'code': \"# closure patch\\\\nimport json, time\\\\ndef generate_module_from_desc(desc):\\\\n    dj = json.dumps(desc, ensure_ascii=False)\\\\n    return '\\\\n'.join(['# closure-gen','DESC = '+dj,'def run(ctx=None):','    return DESC'])\",\\n            'ts': time.time()\\n        }\\n    return {'desc_type':'self_driven_evolver_nop'}"
}
