{
  "desc_type": "module_emit",
  "name": "graal_gap_falsifier",
  "code": "import os, json, time, hashlib\\nBASE = os.path.join('mem','graal')\\nFINAL = os.path.join(BASE,'final_form.json')\\nINV   = os.path.join(BASE,'invariants.json')\\nGAPS  = os.path.join(BASE,'gaps.log')\\nMISS  = os.path.join(BASE,'gaps_uncovered.log')\\n\\ndef _load_json(path, default):\\n    if not os.path.exists(path):\\n        return default\\n    with open(path,'r',encoding='utf-8') as f: return json.load(f)\\n\\ndef _covers(final, gap):\\n    # critere volontairement pauvre : si final ou un invariant parle explicitement du gap_kind, on considere que c est couvert\\n    gk = gap.get('gap_kind')\\n    if not gk: return False\\n    txt = json.dumps(final,ensure_ascii=False) if final else ''\\n    if gk in txt: return True\\n    return False\\n\\ndef run(ctx=None):\\n    final = _load_json(FINAL, None)\\n    invs  = _load_json(INV, [])\\n    # on compense avec les invariants : si l un d eux le cite, c est bon\\n    def covers_any(gap):\\n        if _covers(final, gap): return True\\n        gk = gap.get('gap_kind')\\n        for iv in invs:\\n            if gk and gk in json.dumps(iv,ensure_ascii=False):\\n                return True\\n        return False\\n    # on relit les derniers gaps generes\\n    recents = []\\n    if os.path.exists(GAPS):\\n        with open(GAPS,'r',encoding='utf-8') as f:\\n            recents = [json.loads(l) for l in f.readlines()[-20:]]\\n    uncovered = []\\n    for g in recents:\\n        if not covers_any(g):\\n            uncovered.append(g)\\n    if uncovered:\\n        with open(MISS,'a',encoding='utf-8') as f:\\n            for u in uncovered: f.write(json.dumps(u,ensure_ascii=False)+'\\\\n')\\n        return {\\n            'desc_type':'graal_gap_report',\\n            'uncovered': uncovered,\\n            'ts': time.time(),\\n            'note': 'these are behaviours your current final form does NOT explain'\\n        }\\n    return {'desc_type':'graal_gap_clean','ts':time.time()}"
}
