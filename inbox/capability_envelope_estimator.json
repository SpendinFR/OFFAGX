{
  "desc_type": "module_emit",
  "name": "capability_envelope_estimator",
  "code": "import os, json, time\\nMEM_BASE = os.path.join('mem','capabilities')\\nOS_ACTS = {'ls','pwd','whoami','uname','cat','echo'}\\n\\ndef run(ctx=None):\\n    os.makedirs(MEM_BASE, exist_ok=True)\\n    # 1) on regarde les streams connus\\n    from_glob = list((ctx or {}).get('streams') or [])\\n    thinkers = []  # modules qui produisent juste des descs\\n    actors = []    # modules qui ont un effet hors desc (os, emitted, research)\\n    for name in from_glob:\\n        if not name.startswith('module:'):\\n            continue\\n        if 'emitted/' in name or 'research/' in name:\\n            actors.append(name); continue\\n        # on fait une heuristique simple sur le nom\\n        if any(k in name for k in ('os_','host_','bridge_','driver_')):\\n            actors.append(name)\\n        else:\\n            thinkers.append(name)\\n    # 2) si on n a que des thinkers ou des actors bridé OS → on est boxed\\n    boxed = False\\n    if actors:\\n        # check si c est que du OS bridé\\n        only_os = True\\n        for a in actors:\\n            if not any(k in a for k in ('os_','host_','emit','research_')):\\n                only_os = False\\n                break\\n        if only_os:\\n            boxed = True\\n    else:\\n        boxed = True\\n    rep = {\\n        'desc_type': 'capability_envelope',\\n        'boxed': boxed,\\n        'thinkers': thinkers[:200],\\n        'actors': actors[:200],\\n        'ts': time.time()\\n    }\\n    with open(os.path.join(MEM_BASE,'last.json'),'w',encoding='utf-8') as f: json.dump(rep,f,ensure_ascii=False,indent=2)\\n    return rep"
}
