{
  "desc_type": "planner_frag",
  "name": "limit_shape_tester",
  "code": "import os, json, time\\nSRC = 'mem/limit_hyp'\\n\\ndef _last_hyp():\\n    if not os.path.exists(SRC): return None\\n    files = sorted([f for f in os.listdir(SRC) if f.endswith('.json')])\\n    if not files: return None\\n    with open(os.path.join(SRC, files[-1]), 'r', encoding='utf-8') as f: return json.load(f)\\n\\ndef plan(ctx: dict) -> list[dict]:\\n    gen = ctx.get('gen',0)\\n    if gen % 11 != 0: return []\\n    hyp = _last_hyp()\\n    if not hyp: return []\\n    core = hyp.get('core_modules', [])\\n    growing = hyp.get('monotonic_additions', [])\\n    tests = []\\n    # test1 : que se passe-t-il si on supprime 1 module suppos√© \"core\" ?\\n    for m in core[:2]:\\n        tests.append({\\n            'desc_type': 'cortex_evolution_plan',\\n            'op': 'simulate_removal',\\n            'target_module_root': m,\\n            'expected': 'system_recreates_or_degrades'\\n        })\\n    # test2 : que se passe-t-il si on ajoute un module d'une autre famille ?\\n    tests.append({\\n        'desc_type': 'cortex_evolution_plan',\\n        'op': 'inject_noise_module',\\n        'module_source': \"# noise module\\n def run(ctx=None):\\n  return {'desc_type':'noise_result'}\\n\",\\n        'expected': 'core_resists'\\n    })\\n    return tests\\n"
}
