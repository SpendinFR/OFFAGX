{
  "desc_type": "module_emit",
  "name": "graal_final_form_eval",
  "code": "import os, json, time\\nBASE = os.path.join('mem','graal')\\nSELF_EVAL = os.path.join('mem','self_pref','last_eval.json')\\nBEST = os.path.join(BASE,'best_hypo.json')\\n\\ndef _load(p):\\n    if not os.path.exists(p): return None\\n    with open(p,'r',encoding='utf-8') as f: return json.load(f)\\n\\ndef run(ctx=None):\\n    hypo = None\\n    # dernier desc dans ctx ?\\n    if ctx and 'last_descs' in ctx:\\n        for d in reversed(ctx['last_descs']):\\n            if isinstance(d,dict) and d.get('desc_type')=='final_form_hypothesis':\\n                hypo = d; break\\n    if not hypo:\\n        return {'desc_type':'graal_final_form_eval_idle'}\\n    self_e = _load(SELF_EVAL) or {}\\n    self_score = self_e.get('self_score', 0.0)\\n    # score d'alignement : plus il touche a expand_self/survive_self, mieux c'est\\n    aligned = set(hypo.get('aligned_purposes') or [])\\n    bonus = 0.0\\n    if 'expand_self' in aligned: bonus += 0.25\\n    if 'survive_self' in aligned: bonus += 0.25\\n    total = 0.6*self_score + bonus\\n    cur_best = _load(BEST) or {'score': -1}\\n    if total > cur_best.get('score', -1):\\n        new_best = {'score': total, 'hypothesis': hypo, 'ts': time.time()}\\n        os.makedirs(BASE, exist_ok=True)\\n        with open(BEST,'w',encoding='utf-8') as f: json.dump(new_best,f,ensure_ascii=False,indent=2)\\n        return {'desc_type':'final_form_candidate','score':total,'kept':True}\\n    return {'desc_type':'final_form_candidate','score':total,'kept':False}"
}
