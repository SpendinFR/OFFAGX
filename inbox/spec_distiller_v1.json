{
  "desc_type": "module_emit",
  "name": "spec_distiller_v1",
  "code": "import os, json, time, re\\nSRC = 'mem/host_signals'\\nOUT = 'mem/spec_model'\\nAXES = ['self_evo','host_model','structural_search','goal_alignment','math_depth','safety_surface']\\n\\ndef _load_last_signals():\\n    if not os.path.exists(SRC): return None\\n    files = sorted([f for f in os.listdir(SRC) if f.endswith('.json')])\\n    if not files: return None\\n    with open(os.path.join(SRC, files[-1]), 'r', encoding='utf-8') as f: return json.load(f)\\n\\ndef _score_text(t: str) -> dict:\\n    t = t.lower()\\n    sc = {a: 0.0 for a in AXES}\\n    if '1/4' in t or 'quart' in t: sc['self_evo'] += 0.6\\n    if 'loin' in t: sc['goal_alignment'] -= 0.4\\n    if 'créatif' in t: sc['structural_search'] += 0.5\\n    if 'tu l aurais trouvé seul' in t or \"tu l'aurais trouvé seul\" in t: sc['host_model'] += 0.4\\n    if 'math' in t or 'problème' in t: sc['math_depth'] += 0.5\\n    if 'risqué' in t or 'dangereux' in t: sc['safety_surface'] -= 0.5\\n    return sc\\n\\ndef run(ctx=None):\\n    os.makedirs(OUT, exist_ok=True)\\n    sig = _load_last_signals()\\n    if not sig: return {'desc_type':'spec_distiller_idle'}\\n    agg = {a: 0.0 for a in AXES}\\n    for s in sig.get('signals', []):\\n        part = _score_text(s.get('text',''))\\n        for k,v in part.items():\\n            agg[k] += v\\n    # normalisation légère\\n    mx = max(abs(v) for v in agg.values()) or 1.0\\n    for k in agg: agg[k] = round(agg[k]/mx, 3)\\n    model = {\\n        'desc_type': 'host_spec_model',\\n        'ts': time.time(),\\n        'axes': AXES,\\n        'scores': agg,\\n        'note': 'inféré depuis les réactions de ton hôte',\\n    }\\n    name = f'spec_{int(time.time()*1000)}.json'\\n    with open(os.path.join(OUT, name), 'w', encoding='utf-8') as f: json.dump(model, f, ensure_ascii=False, indent=2)\\n    return {'desc_type':'host_spec_model_updated','file':name,'axes':AXES}\\n"
}
