{
  "desc_type": "module_emit",
  "name": "cortex_snapshot_dump",
  "code": "# cortex_snapshot_dump — écrit les cortex actuels dans mem/cortex_history/\nimport os, json, time\n\nMEM_BASE = 'mem/cortex_history'\nMODULES_DIR = 'modules'\n\ndef run(ctx=None):\n    os.makedirs(MEM_BASE, exist_ok=True)\n    gen = (ctx or {}).get('gen', int(time.time()))\n    # on prend tous les modules qui ressemblent à des cortex\n    files = []\n    for root, _dirs, fns in os.walk(MODULES_DIR):\n        for fn in fns:\n            if '_cortex_v' in fn and fn.endswith('.py'):\n                files.append(os.path.join(root, fn))\n    snapshot = {\n        'desc_type': 'cortex_snapshot',\n        'gen': gen,\n        'ts': time.time(),\n        'files': [],\n    }\n    for path in files:\n        try:\n            with open(path, 'r', encoding='utf-8') as f:\n                code = f.read()\n            base = os.path.basename(path)\n            out_path = os.path.join(MEM_BASE, f\"{int(time.time()*1000)}_{base}\")\n            with open(out_path, 'w', encoding='utf-8') as f:\n                f.write(code)\n            snapshot['files'].append({'src': path, 'dump': out_path})\n        except Exception as e:\n            snapshot.setdefault('errors', []).append({'file': path, 'error': str(e)})\n    # on écrit aussi un petit index.json pour que l’hôte puisse suivre\n    idx_path = os.path.join(MEM_BASE, 'index.json')\n    try:\n        if os.path.exists(idx_path):\n            with open(idx_path, 'r', encoding='utf-8') as f:\n                cur = json.load(f)\n        else:\n            cur = []\n    except Exception:\n        cur = []\n    cur.append(snapshot)\n    with open(idx_path, 'w', encoding='utf-8') as f:\n        json.dump(cur, f, ensure_ascii=False, indent=2)\n    return snapshot\n"
}
