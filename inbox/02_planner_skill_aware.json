{
  "desc_type": "planner_frag",
  "name": "planner_skill_aware_v1",
  "code": "import os, json, time\nREG_PATH = 'mem/skills_registry.json'\nCALLS_PATH = 'mem/skill_calls.json'\n\ndef _known_skills():\n    if not os.path.exists(REG_PATH):\n        return set()\n    try:\n        data = json.load(open(REG_PATH, 'r', encoding='utf-8'))\n    except Exception:\n        return set()\n    return {item['name'] for item in data if 'name' in item}\n\n\ndef _append_call(call: dict):\n    calls = []\n    if os.path.exists(CALLS_PATH):\n        try:\n            calls = json.load(open(CALLS_PATH, 'r', encoding='utf-8'))\n        except Exception:\n            calls = []\n    calls.append(call)\n    with open(CALLS_PATH, 'w', encoding='utf-8') as f:\n        json.dump(calls, f, ensure_ascii=False, indent=2)\n\n\ndef plan(ctx):\n    out = []\n    known = _known_skills()\n    inbox_descs = ctx.get('inbox_descs') or []\n    for d in inbox_descs:\n        missing = d.get('missing') or d.get('needs') or []\n        dt = d.get('desc_type') or 'unknown'\n        if not missing:\n            continue\n        skill_name = f\"skill_for_{dt}\"\n        if any(skill_name in k for k in known):\n            # on sait faire → on programme un appel\n            _append_call({\n                'skill_name': list(known)[0] if skill_name not in known else skill_name,\n                'ctx': {\n                    'source_desc': d,\n                    'text': d.get('text') or d.get('payload') or ''\n                },\n                'ts': time.time()\n            })\n            out.append({'desc_type': 'skill_use_planned', 'skill': skill_name, 'ts': time.time()})\n        else:\n            # on ne sait pas faire → on demande un skill\n            out.append({\n                'desc_type': 'skill_request',\n                'name': skill_name,\n                'goal': f\"fournir {missing} pour la tâche {dt}\",\n                'priority': 'medium',\n                'ts': time.time()\n            })\n    return out\n"
}
