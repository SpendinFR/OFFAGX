{
  "desc_type": "module_emit",
  "name": "host_forward_model",
  "code": "import os, json, time, re\\nBASE = 'mem/oracle'\\nCAND = 'mem/cortex_candidates'\\nOUT = 'mem/cortex_scores'\\n\\ndef _load_constraints():\\n    p = os.path.join(BASE,'constraint_model.json')\\n    if not os.path.exists(p): return None\\n    with open(p,'r',encoding='utf-8') as f: return json.load(f)\\n\\ndef _load_candidates():\\n    if not os.path.exists(CAND): return []\\n    out = []\\n    for f in os.listdir(CAND):\\n        if f.endswith('.json'):\\n            with open(os.path.join(CAND,f),'r',encoding='utf-8') as fh: out.append(json.load(fh))\\n    return out\\n\\ndef _score_candidate(cand, cons):\\n    # scoring très simple : pénaliser les modules qui parlent host_patch, récompenser research/math\\n    score = 0\\n    mods = cand.get('modules',[])\\n    for m in mods:\\n        src = m.get('src','')\\n        if 'host_patch' in src: score -= 3\\n        if 'research_task' in src or 'math_task' in src: score += 2\\n        if 'engine_patch' in src: score += 1\\n    # appliquer contraintes apprises\\n    if cons:\\n        for r in cons.get('rules',[]):\\n            if r.get('verdict')=='risky': score -= 1\\n    return score\\n\\ndef run(ctx=None):\\n    cons = _load_constraints()\\n    cands = _load_candidates()\\n    if not cands: return {'desc_type':'host_forward_idle'}\\n    os.makedirs(OUT, exist_ok=True)\\n    scored = []\\n    for c in cands:\\n        s = _score_candidate(c, cons)\\n        scored.append({'variant_id': c.get('variant_id'), 'score': s})\\n    fname = f'scores_{int(time.time()*1000)}.json'\\n    with open(os.path.join(OUT,fname),'w',encoding='utf-8') as f: json.dump({'ts':time.time(),'scored':scored},f,ensure_ascii=False,indent=2)\\n    return {'desc_type':'host_forward_scores_written','file':fname,'count':len(scored)}\\n"
}
