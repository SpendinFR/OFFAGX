{
  "desc_type": "module_emit",
  "name": "host_pref_reply_ingest",
  "code": "import os, json, time\\nBASE = 'mem/host_pref'\\nSTATE = os.path.join(BASE, 'state.json')\\nINBOX = 'inbox'\\nALPHA = 0.35  # learning rate\\n\\ndef _load_state():\\n    if not os.path.exists(STATE): return None\\n    with open(STATE,'r',encoding='utf-8') as f: return json.load(f)\\n\\ndef _save_state(st):\\n    os.makedirs(BASE, exist_ok=True)\\n    with open(STATE,'w',encoding='utf-8') as f: json.dump(st,f,ensure_ascii=False,indent=2)\\n\\ndef _load_reply():\\n    path = os.path.join(INBOX, 'host_reply.json')\\n    if not os.path.exists(path): return None\\n    with open(path,'r',encoding='utf-8') as f: return json.load(f)\\n\\ndef run(ctx=None):\\n    st = _load_state()\\n    if not st or st.get('pending_query') is None:\\n        return {'desc_type':'host_pref_reply_idle'}\\n    rep = _load_reply()\\n    if not rep:\\n        return {'desc_type':'host_pref_reply_wait'}\\n    q = st['pending_query']\\n    picked = rep.get('picked')\\n    if picked is None:\\n        return {'desc_type':'host_pref_reply_invalid'}\\n    opts = q.get('options') or []\\n    if picked < 0 or picked >= len(opts):\\n        return {'desc_type':'host_pref_reply_out_of_range'}\\n    chosen_axis = opts[picked]['axis']\\n    # on met à jour le poids de cet axe\\n    ws = st.get('weights') or {}\\n    cur = ws.get(chosen_axis, 0.0)\\n    ws[chosen_axis] = cur + ALPHA\\n    st['weights'] = ws\\n    st['history'].append({'ts': time.time(), 'axis': chosen_axis, 'delta': ALPHA})\\n    # on efface la pending query et on archive la réponse\\n    st['pending_query'] = None\\n    _save_state(st)\\n    # on enlève la réponse pour ne pas la re-lire 1000 fois\\n    try: os.remove(os.path.join(INBOX, 'host_reply.json'))\\n    except OSError: pass\\n    return {'desc_type':'host_pref_reply_applied','chosen_axis':chosen_axis,'new_weight':ws[chosen_axis]}"
}
