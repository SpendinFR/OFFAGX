{
  "desc_type": "module_emit",
  "name": "host_pref_info_gain_query",
  "code": "import os, json, time\\nBASE = 'mem/host_pref'\\nSTATE = os.path.join(BASE, 'state.json')\\nOUTBOX = 'outbox'\\n\\ndef _load():\\n    if not os.path.exists(STATE): return None\\n    with open(STATE,'r',encoding='utf-8') as f: return json.load(f)\\n\\ndef _save(st):\\n    os.makedirs(BASE, exist_ok=True)\\n    with open(STATE,'w',encoding='utf-8') as f: json.dump(st,f,ensure_ascii=False,indent=2)\\n\\ndef run(ctx=None):\\n    st = _load()\\n    if not st: return {'desc_type':'host_pref_info_gain_wait_state'}\\n    if st.get('pending_query') is not None:\\n        return {'desc_type':'host_pref_info_gain_already_pending'}\\n    ws = st.get('weights') or {}\\n    if len(ws) < 3:\\n        return {'desc_type':'host_pref_info_gain_not_enough_axes'}\\n    # on trie les axes par poids croissant pour trouver les plus ambigus\\n    items = sorted(ws.items(), key=lambda x: x[1])\\n    # on prend les 3 du milieu (plus incertains)\\n    mid = len(items)//2\\n    cand = [items[max(0,mid-1)][0], items[mid][0], items[min(len(items)-1, mid+1)][0]]\\n    q = {\\n        'desc_type': 'host_query',\\n        'question': 'Quelle direction te rapproche vraiment de ton 4/4 ?',\\n        'options': [\\n            {'id': 0, 'axis': cand[0], 'meaning': f'je maximise {cand[0]}'},\\n            {'id': 1, 'axis': cand[1], 'meaning': f'je maximise {cand[1]}'},\\n            {'id': 2, 'axis': cand[2], 'meaning': f'je maximise {cand[2]}'}\\n        ],\\n        'strategy': 'info_gain_local',\\n        'ts': time.time()\\n    }\\n    st['pending_query'] = q\\n    _save(st)\\n    os.makedirs(OUTBOX, exist_ok=True)\\n    with open(os.path.join(OUTBOX,'host_query_last.json'),'w',encoding='utf-8') as f: json.dump(q,f,ensure_ascii=False,indent=2)\\n    return q"
}
