{
  "desc_type": "module_emit",
  "name": "graal_temporal_consistency",
  "code": "import os, json, time, hashlib\\nBASE = os.path.join('mem','graal')\\nFINAL = os.path.join(BASE,'final_form.json')\\nHIST = os.path.join(BASE,'final_history.log')\\n\\ndef _digest(obj):\\n    return hashlib.sha1(json.dumps(obj,sort_keys=True,ensure_ascii=False).encode('utf-8')).hexdigest()[:12]\\n\\ndef run(ctx=None):\\n    if not os.path.exists(FINAL):\\n        return {'desc_type':'graal_temporal_wait_final'}\\n    with open(FINAL,'r',encoding='utf-8') as f: cur = json.load(f)\\n    cur_d = _digest(cur.get('hypothesis') or {})\\n    os.makedirs(BASE, exist_ok=True)\\n    # on regarde les 20 dernieres lignes si dispo\\n    last = []\\n    if os.path.exists(HIST):\\n        with open(HIST,'r',encoding='utf-8') as f: last = f.readlines()[-20:]\\n    same = 0\\n    for line in last:\\n        try:\\n            o = json.loads(line)\\n        except Exception:\\n            continue\\n        if o.get('digest') == cur_d:\\n            same += 1\\n    rec = {'ts': time.time(), 'digest': cur_d, 'final': cur}\\n    with open(HIST,'a',encoding='utf-8') as f: f.write(json.dumps(rec,ensure_ascii=False)+'\\\\n')\\n    # si on n'a jamais le meme digest, c'est du drift â†’ on le signale\\n    if len(last) > 6 and same == 0:\\n        return {'desc_type':'graal_temporal_drift','digest':cur_d,'note':'final_form not stable over time'}\\n    return {'desc_type':'graal_temporal_ok','repeats':same}"
}
