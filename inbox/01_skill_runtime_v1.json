{
  "desc_type": "module_emit",
  "name": "skill_runtime_v1",
  "code": "import os, json, time, traceback\nCALLS_PATH = 'mem/skill_calls.json'\n\ndef _exec_skill_file(path: str, ctx: dict):\n    code = open(path, 'r', encoding='utf-8').read()\n    g = {\n        '__builtins__': __builtins__,\n        'os': os,\n        'json': json,\n        'time': time,\n        'traceback': traceback,\n    }\n    exec(code, g, g)\n    fn = g.get('run')\n    if callable(fn):\n        return fn(ctx)\n    return {'desc_type': 'skill_no_run', 'file': path}\n\n\ndef run(ctx=None):\n    if not os.path.exists(CALLS_PATH):\n        return {'desc_type': 'skill_runtime_idle', 'ts': time.time()}\n    try:\n        calls = json.load(open(CALLS_PATH, 'r', encoding='utf-8'))\n    except Exception:\n        return {'desc_type': 'skill_runtime_error', 'reason': 'cannot_read_calls', 'ts': time.time()}\n    out = []\n    remaining = []\n    for call in calls:\n        name = call.get('skill_name')\n        skill_ctx = call.get('ctx') or {}\n        # chemins possibles\n        cand1 = os.path.join('modules', 'emitted', name + '.py')\n        cand2 = os.path.join('modules', 'emitted', name)\n        skill_path = cand1 if os.path.exists(cand1) else cand2\n        if not os.path.exists(skill_path):\n            # pas encore généré → on le garde\n            remaining.append(call)\n            continue\n        try:\n            res = _exec_skill_file(skill_path, skill_ctx)\n            if isinstance(res, dict) and 'desc_type' in res:\n                out.append(res)\n        except Exception as e:\n            out.append({'desc_type': 'skill_runtime_error', 'skill': name, 'error': str(e)})\n    # on réécrit les appels pas traités\n    with open(CALLS_PATH, 'w', encoding='utf-8') as f:\n        json.dump(remaining, f, ensure_ascii=False, indent=2)\n    if out:\n        return out\n    return {'desc_type': 'skill_runtime_idle', 'ts': time.time()}\n"
}
