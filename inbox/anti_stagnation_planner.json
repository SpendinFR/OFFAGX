{
  "desc_type": "module_emit",
  "name": "anti_stagnation_planner",
  "code": "import time, json, os\\nHYP = 'mem/host_model/implicit_target_hypothesis.json'\\n\\ndef _load_hyp():\\n    if not os.path.exists(HYP): return None\\n    with open(HYP,'r',encoding='utf-8') as f: return json.load(f)\\n\\ndef run(ctx=None):\\n    # on regarde si dans ctx il y a un stagnation_event\\n    descs = (ctx or {}).get('descs') or []\\n    stagn = None\\n    for d in descs:\\n        if d.get('desc_type') == 'stagnation_event':\\n            stagn = d; break\\n    if not stagn:\\n        return {'desc_type':'anti_stag_idle'}\\n    hyp = _load_hyp() or {}\\n    target = hyp.get('hyp') or 'unsure'\\n    # on choisit une stratégie de rupture de clôture\\n    # 1) grammar_escape : générer un module avec un desc_type inconnu + un mini DSL\\n    # 2) plane_fusion : mélanger research + social\\n    # 3) engine_shape_probe : décrire un moteur que le générateur actuel ne sait pas rendre\\n    plans = []\\n    plans.append({\\n        'desc_type': 'closure_break_plan',\\n        'mode': 'grammar_escape',\\n        'note': 'auto because tri_eval plateau',\\n        'ts': time.time()\\n    })\\n    if target == 'mathward':\\n        plans.append({\\n            'desc_type': 'closure_break_plan',\\n            'mode': 'plane_fusion',\\n            'planes': ['research','social'],\\n            'note': 'mix math+social for host probing'\\n        })\\n    else:\\n        plans.append({\\n            'desc_type': 'closure_break_plan',\\n            'mode': 'engine_shape_probe',\\n            'shape': [1,2,3,255],\\n            'note': 'force generator to face unknown shape'\\n        })\\n    return plans"
}
