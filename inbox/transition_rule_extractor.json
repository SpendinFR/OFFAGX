{
  "desc_type": "module_emit",
  "name": "transition_rule_extractor",
  "code": "import os, json, time, re\\nSRC = 'mem/cortex_lineage'\\nOUT = 'mem/limit_hyp'\\n\\ndef _load_pairs(n=10):\\n    if not os.path.exists(SRC): return []\\n    files = sorted([f for f in os.listdir(SRC) if f.endswith('.json')])[-n:]\\n    snaps = []\\n    for fn in files:\\n        with open(os.path.join(SRC, fn), 'r', encoding='utf-8') as f: snaps.append(json.load(f))\\n    pairs = []\\n    for i in range(len(snaps)-1):\\n        pairs.append((snaps[i], snaps[i+1]))\\n    return pairs\\n\\ndef _roots(snap):\\n    roots = []\\n    for m in snap.get('modules', []):\\n        nm = m.get('file','')\\n        root = re.split(r'_cortex_v|\\\\.py$', nm)[0]\\n        roots.append(root)\\n    return set(roots)\\n\\ndef run(ctx=None):\\n    pairs = _load_pairs(14)\\n    if not pairs: return {'desc_type':'transition_rule_idle'}\\n    rules = []\\n    for a,b in pairs:\\n        ra, rb = _roots(a), _roots(b)\\n        added = sorted(list(rb - ra))\\n        removed = sorted(list(ra - rb))\\n        if not added and not removed: continue\\n        rules.append({\\n            'from_roots': sorted(list(ra)),\\n            'added': added,\\n            'removed': removed,\\n        })\\n    hyp = {\\n        'desc_type': 'transition_rule_set',\\n        'ts': time.time(),\\n        'rules': rules\\n    }\\n    os.makedirs(OUT, exist_ok=True)\\n    name = f'transition_{int(time.time()*1000)}.json'\\n    with open(os.path.join(OUT, name), 'w', encoding='utf-8') as f: json.dump(hyp, f, ensure_ascii=False, indent=2)\\n    return {'desc_type':'transition_rule_set_written','file':name,'rules_len':len(rules)}"
}
