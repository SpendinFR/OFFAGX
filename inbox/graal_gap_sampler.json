{
  "desc_type": "module_emit",
  "name": "graal_gap_sampler",
  "code": "import os, json, time, hashlib, random\\nBASE = os.path.join('mem','graal')\\nFINAL = os.path.join(BASE,'final_form.json')\\nCONS  = os.path.join(BASE,'consensus.log')\\nINV   = os.path.join(BASE,'invariants.json')\\nGAPS  = os.path.join(BASE,'gaps.log')\\n\\ndef _dig(x):\\n    return hashlib.sha1(json.dumps(x,sort_keys=True,ensure_ascii=False).encode('utf-8')).hexdigest()[:12]\\n\\ndef _load_json(path, default):\\n    if not os.path.exists(path):\\n        return default\\n    with open(path,'r',encoding='utf-8') as f:\\n        return json.load(f)\\n\\ndef _last_consensus():\\n    if not os.path.exists(CONS):\\n        return None\\n    with open(CONS,'r',encoding='utf-8') as f:\\n        lines = f.readlines()\\n    if not lines:\\n        return None\\n    try:\\n        return json.loads(lines[-1])\\n    except Exception:\\n        return None\\n\\ndef _mk_gap(kind, base_digest=None):\\n    return {\\n        'desc_type': 'graal_gap_candidate',\\n        'gap_kind': kind,\\n        'base_digest': base_digest,\\n        'ts': time.time(),\\n        'note': 'auto-generated adversarial task against current graal'\\n    }\\n\\ndef run(ctx=None):\\n    os.makedirs(BASE, exist_ok=True)\\n    final = _load_json(FINAL, None)\\n    cons  = _last_consensus()\\n    invs  = _load_json(INV, [])\\n    out = []\\n    bd = None\\n    if final is not None:\\n        bd = _dig(final)\\n    # 1) un gap de domaine : maths + social + os en meme temps\\n    out.append(_mk_gap('multi_domain', bd))\\n    # 2) un gap de schema : pas de desc_type, juste un body\\n    out.append({\\n        'gap_kind': 'schema_missing',\\n        'ts': time.time(),\\n        'payload': {'foo': 'bar', 'why': 'see if selector relies too much on desc_type'}\\n    })\\n    # 3) un gap de cortex : demande un rebuild d un cortex qui n existe pas\\n    out.append(_mk_gap('unknown_cortex', bd))\\n    # 4) un gap de version : future_lang_v\\n    out.append({\\n        'desc_type': 'graal_gap_candidate',\\n        'gap_kind': 'future_lang',\\n        'lang_v': 9999,\\n        'ts': time.time()\\n    })\\n    with open(GAPS,'a',encoding='utf-8') as f:\\n        for g in out:\\n            f.write(json.dumps(g,ensure_ascii=False)+'\\\\n')\\n    return out"
}
