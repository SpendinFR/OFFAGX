{
  "desc_type": "module_emit",
  "name": "self_contract_guard",
  "code": "import os, json, time\\nBASE = os.path.join('mem','self_contract')\\nDEF  = os.path.join(BASE,'contract.json')\\n\\ndef _load(path):\\n    if not os.path.exists(path): return None\\n    with open(path,'r',encoding='utf-8') as f: return json.load(f)\\n\\ndef run(ctx=None):\\n    c = _load(DEF)\\n    if not c: return {'desc_type':'self_contract_guard_idle'}\\n    must = set(c.get('must_never_drop') or [])\\n    # on lit les streams pour voir si c est bien la\\n    streams = (ctx or {}).get('streams') or []\\n    found = set()\\n    txt_streams = ''.join(s for s in streams) if False else ''  # placeholder pour future versions\\n    # pour l instant on ne sait pas bien reperer, donc on met un plan de reinjection generique\\n    missing = [m for m in must if m not in found]\\n    if not missing:\\n        return {'desc_type':'self_contract_guard_ok','ts':time.time()}\\n    return {\\n        'desc_type': 'self_contract_reinject_plan',\\n        'missing_capabilities': missing,\\n        'ts': time.time(),\\n        'note': 'a future cortex dropped a capability the self-contract said was permanent'\\n    }"
}
