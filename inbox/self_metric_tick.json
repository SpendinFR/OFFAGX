{
  "desc_type": "module_emit",
  "name": "self_metric_tick",
  "code": "import os, json, time\\nBASE = 'mem/self_pref'\\nSTATE = os.path.join(BASE, 'state.json')\\nHIST = os.path.join(BASE, 'metric.log')\\n\\ndef _load_state():\\n    if not os.path.exists(STATE): return None\\n    with open(STATE,'r',encoding='utf-8') as f: return json.load(f)\\n\\ndef _save_state(st):\\n    os.makedirs(BASE, exist_ok=True)\\n    with open(STATE,'w',encoding='utf-8') as f: json.dump(st,f,ensure_ascii=False,indent=2)\\n\\ndef run(ctx=None):\\n    st = _load_state()\\n    if not st: return {'desc_type':'self_metric_wait_bootstrap'}\\n    # signaux venant du noyau (streams = ctx.get('streams'))\\n    streams = (ctx or {}).get('streams') or []\\n    n_mods = len([s for s in streams if s.startswith('module:')])\\n    n_inbox = len([s for s in streams if s.startswith('inbox:')])\\n    # score naïf \\n    score = 0.0\\n    score += min(n_mods/50.0, 1.0) * st['weights'].get('self_expansion',1.0)\\n    score += min(n_inbox/20.0, 1.0) * st['weights'].get('world_reach',1.0)\\n    # closure: est-ce qu'on a nos cortex générés ?\\n    has_gen = any('generator' in s for s in streams)\\n    if has_gen: score += 0.5 * st['weights'].get('closure',1.0)\\n    entry = {'ts': time.time(), 'score': score, 'mods': n_mods, 'inbox': n_inbox}\\n    os.makedirs(BASE, exist_ok=True)\\n    with open(HIST,'a',encoding='utf-8') as f: f.write(json.dumps(entry,ensure_ascii=False)+'\\\\n')\\n    st['last_self_score'] = score\\n    _save_state(st)\\n    return {'desc_type':'self_metric_observed','score':score}"
}
