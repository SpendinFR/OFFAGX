{
  "desc_type": "module_emit",
  "name": "limit_shape_mdl_selector",
  "code": "import os, json, time, math\\nSRC = 'mem/limit_hyp'\\nOUT = 'mem/limit_hyp'\\n\\ndef _size(obj):\\n    try: return len(json.dumps(obj, ensure_ascii=False))\\n    except Exception: return 999999\\n\\ndef _load_hyps(max_n=40):\\n    if not os.path.exists(SRC): return []\\n    files = sorted([f for f in os.listdir(SRC) if f.endswith('.json')])[-max_n:]\\n    out = []\\n    for fn in files:\\n        with open(os.path.join(SRC, fn), 'r', encoding='utf-8') as f: out.append(json.load(f))\\n    return out\\n\\ndef run(ctx=None):\\n    hyps = _load_hyps()\\n    if not hyps: return {'desc_type':'limit_shape_mdl_idle'}\\n    # coût très simple : longueur_json - bonus_pour_core\\n    scored = []\\n    for h in hyps:\\n        core = h.get('core_modules') or []\\n        grow = h.get('monotonic_additions') or []\\n        cost = _size(h) - 5*len(core) - 2*len(grow)\\n        scored.append((cost, h))\\n    scored.sort(key=lambda x: x[0])\\n    best_cost, best = scored[0]\\n    name = f'limit_best_{int(time.time()*1000)}.json'\\n    with open(os.path.join(OUT, name), 'w', encoding='utf-8') as f: json.dump({'desc_type':'limit_shape_mdl_best','best':best,'cost':best_cost,'ts':time.time()}, f, ensure_ascii=False, indent=2)\\n    return {'desc_type':'limit_shape_mdl_best','cost':best_cost,'core':best.get('core_modules',[]),'growing':best.get('monotonic_additions',[])}"
}
