{
  "desc_type": "module_emit",
  "name": "graal_invariant_lock",
  "code": "import os, json, time\\nBASE = os.path.join('mem','graal')\\nINV = os.path.join(BASE,'invariants.json')\\n\\ndef run(ctx=None):\\n    # on s'attend a etre appele juste apres un graal_consensus\\n    evts = []\\n    streams = (ctx or {}).get('streams') or []\\n    # le noyau reinjectera le consensus dans le pool, on ne le lit pas directement ici\\n    # donc on regarde si un fichier consensus.log existe\\n    cons_log = os.path.join(BASE,'consensus.log')\\n    if not os.path.exists(cons_log):\\n        return {'desc_type':'graal_invariant_wait_consensus'}\\n    with open(cons_log,'r',encoding='utf-8') as f: lines = f.readlines()[-5:]\\n    if not lines:\\n        return {'desc_type':'graal_invariant_no_recent'}\\n    last = json.loads(lines[-1])\\n    inv = {\\n        'ts': time.time(),\\n        'digest': last.get('digest'),\\n        'required_fields': ['desc_type','ts'],\\n        'preferred_views': ['self','research','struct'],\\n        'note': 'invariant locked from multi-view consensus'\\n    }\\n    os.makedirs(BASE, exist_ok=True)\\n    old = []\\n    if os.path.exists(INV):\\n        with open(INV,'r',encoding='utf-8') as f: old = json.load(f)\\n    old.append(inv)\\n    with open(INV,'w',encoding='utf-8') as f: json.dump(old,f,ensure_ascii=False,indent=2)\\n    return {'desc_type':'graal_invariant_locked','digest': inv['digest'],'n': len(old)}"
}
