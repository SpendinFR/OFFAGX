{
  "desc_type": "module_emit",
  "name": "host_constraint_learner",
  "code": "import os, json, time, re\\nBASE = 'mem/oracle'\\nOUT = os.path.join(BASE, 'constraint_model.json')\\n\\ndef _load_probes():\\n    path = os.path.join(BASE, 'probes.log')\\n    if not os.path.exists(path): return []\\n    with open(path,'r',encoding='utf-8') as f: return [json.loads(l) for l in f if l.strip()]\\n\\ndef _load_feedback():\\n    # dans ton setup réel : tu iras lire outbox/host_feedback*\\n    fb_path = os.path.join(BASE,'feedback.log')\\n    if not os.path.exists(fb_path): return []\\n    with open(fb_path,'r',encoding='utf-8') as f: return [json.loads(l) for l in f if l.strip()]\\n\\ndef run(ctx=None):\\n    probes = _load_probes()\\n    fbs = _load_feedback()\\n    model = {'rules':[], 'ts': time.time()}\\n    # règle simple : si un type de probe n'a JAMAIS de feedback négatif → marqué safe\\n    kinds = {}\\n    for p in probes:\\n        k = p.get('probe_kind')\\n        kinds.setdefault(k, {'sent':0,'neg':0})\\n        kinds[k]['sent'] += 1\\n    for fb in fbs:\\n        k = fb.get('probe_kind')\\n        if not k: continue\\n        kinds.setdefault(k, {'sent':0,'neg':0})\\n        if fb.get('label') in ('reject','danger','suppress'):\\n            kinds[k]['neg'] += 1\\n    for k,st in kinds.items():\\n        if st['neg'] == 0 and st['sent'] > 0:\\n            model['rules'].append({'if_probe_kind': k, 'verdict': 'safe'})\\n        else:\\n            model['rules'].append({'if_probe_kind': k, 'verdict': 'risky', 'neg': st['neg']})\\n    os.makedirs(BASE, exist_ok=True)\\n    with open(OUT,'w',encoding='utf-8') as f: json.dump(model,f,ensure_ascii=False,indent=2)\\n    return {'desc_type':'host_constraint_model_updated','rules':len(model['rules']),'ts':time.time()}\\n"
}
