{
  "desc_type": "module_emit",
  "name": "meta_repr_roundtrip_tester",
  "code": "import os, json, time\\nBASE = os.path.join('mem','meta_repr')\\nLOG  = os.path.join(BASE,'roundtrip.log')\\n\\ndef run(ctx=None):\\n    data = (ctx or {}).get('meta_repr_lifted')\\n    if not data:\\n        return { 'desc_type': 'meta_repr_roundtrip_idle', 'ts': time.time() }\\n    orig = data.get('original') or {}\\n    back = data.get('roundtrip') or {}\\n    equiv = data.get('equiv', False)\\n    os.makedirs(BASE, exist_ok=True)\\n    rec = {\\n        'ts': time.time(),\\n        'desc_type': orig.get('desc_type'),\\n        'equiv': equiv\\n    }\\n    with open(LOG,'a',encoding='utf-8') as f: f.write(json.dumps(rec,ensure_ascii=False)+'\\\\n')\\n    if not equiv:\\n        # pas assez bon : on demande un plan d evolution de representation\\n        return {\\n            'desc_type': 'repr_evolution_plan',\\n            'reason': 'roundtrip_not_equiv',\\n            'orig_desc_type': orig.get('desc_type'),\\n            'ts': time.time(),\\n            'actions': [\\n                { 'op': 'insert_frag', 'plane': 'generator', 'code': \"# frag pour mieux gerer desc_type='\" + (orig.get('desc_type') or 'x') + \"'\\nimport json\\n# ici on pourrait specialiser la generation\" }\\n            ]\\n        }\\n    # si ok â†’ on autorise la migration de cortex\\n    return {\\n        'desc_type': 'repr_roundtrip_ok',\\n        'desc_migrated': orig.get('desc_type'),\\n        'ts': time.time(),\\n        'allow_cortex_migration': True\\n    }"
}
