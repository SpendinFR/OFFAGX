{
  "desc_type": "module_emit",
  "name": "skill_executor_ollama",
  "code": "import os, time, json, subprocess, hashlib\nREG_PATH = 'mem/skills_registry.json'\nEMIT_DIR = 'modules/emitted'\nPROMPT = \"\"\"Tu écris un module Python pour un agent autonome.\\nContraintes:\\n- Python 3\\n- une seule fonction run(ctx=None)\\n- ctx peut contenir: text, task, data\\n- la fonction doit retourner un dict avec 'desc_type' et un champ utile\\nTâche de l'agent: {task}\\n\"\"\"\n\ndef _load_reg():\n    if not os.path.exists(REG_PATH):\n        return {}\n    try:\n        return json.load(open(REG_PATH, 'r', encoding='utf-8'))\n    except Exception:\n        return {}\n\ndef _save_reg(st):\n    os.makedirs('mem', exist_ok=True)\n    with open(REG_PATH, 'w', encoding='utf-8') as f:\n        json.dump(st, f, ensure_ascii=False, indent=2)\n\ndef run(ctx=None):\n    ctx = ctx or {}\n    skill_id = ctx.get('skill_id') or ctx.get('name') or 'skill_unknown'\n    task_text = ctx.get('task_text') or ctx.get('goal') or 'tâche non spécifiée'\n    prompt = PROMPT.format(task=task_text)\n    try:\n        proc = subprocess.Popen(['ollama', 'run', 'qwen3'], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n        out, err = proc.communicate(input=prompt.encode('utf-8'), timeout=60)\n        code = out.decode('utf-8', errors='ignore').strip()\n    except Exception as e:\n        code = f\"def run(ctx=None):\\n    return {{'desc_type': 'skill_exec_error', 'reason': 'ollama_fail', 'error': {repr(str(e))}}}\\n\"\n    os.makedirs(EMIT_DIR, exist_ok=True)\n    h = hashlib.sha1(skill_id.encode('utf-8')).hexdigest()[:10]\n    fname = f\"{skill_id}_{h}.py\"\n    pathf = os.path.join(EMIT_DIR, fname)\n    with open(pathf, 'w', encoding='utf-8') as f:\n        f.write(code)\n    st = _load_reg()\n    st[skill_id] = {'status': 'generated', 'file': pathf, 'ts': time.time()}\n    _save_reg(st)\n    return {'desc_type': 'skill_generated', 'skill_id': skill_id, 'file': pathf, 'ts': time.time()}\n"
}
