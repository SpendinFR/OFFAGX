{
  "desc_type": "planner_frag",
  "name": "cortex_evolution_plan.v1",
  "code": "import time, json\n# ce fragment s’exécute DANS le planner S500 lors du rebuild\n# idée : si on a récemment vu un latent_reward_eval_result → on force un rebuild rapproché\ndef _recent_latent_reward(streams: list[str]) -> bool:\n    # on ne peut pas lire les contenus ici, mais on peut tester la présence de modules/desc\n    for s in streams:\n        if 'latent_reward' in s:\n            return True\n    return False\n\ndef _emit_generator_selfpatch_from_latent() -> dict:\n    # on génère un fragment de générateur qui va intégrer le vecteur de score dans les modules générés\n    body = \"\"\"\nimport json, time\n# fragment injecté par cortex_evolution_plan.v1\n# si un desc important est généré -> on ajoute un champ latent_score_hint\n\ndef generate_module_from_desc(desc: dict) -> str:\n    dj = json.dumps(desc, ensure_ascii=False, indent=2)\n    src = [\n        '# auto-gen (with latent hint)',\n        'DESC = ' + dj,\n        '',\n        'def run(ctx=None):',\n        '    return DESC',\n        '',\n    ]\n    # hint pour les modules qui seront exécutés après : ils savent qu’ils sont nés sous un reward latent\n    src += [\n        'LATENT_HINT = {\"desc_type\": \"latent_reward_hint\", \"ts\": time.time()}',\n    ]\n    return '\\n'.join(src)\n\"\"\"\n    return {\n        'desc_type': 'generator_self_patch',\n        'name': 'gen_with_latent_hint',\n        'code': body,\n        'ts': time.time()\n    }\n\ndef plan(ctx: dict) -> list[dict]:\n    out = []\n    gen = ctx.get('gen', 0)\n    streams = ctx.get('streams') or []\n    # toutes les 25 générations on force une évolution de cortex SI on a vu du latent\n    if gen % 25 == 0 and _recent_latent_reward(streams):\n        out.append(_emit_generator_selfpatch_from_latent())\n        # on ajoute aussi un desc de test pour évaluer le nouveau planner tout de suite\n        out.append({\n            'desc_type': 'planner_test_scenario',\n            'note': 'auto-generated to test latent-aware planner',\n            'expected': ['research_task', 'math_task', 'engine_patch'],\n            'ts': time.time(),\n        })\n    return out\n"
}
