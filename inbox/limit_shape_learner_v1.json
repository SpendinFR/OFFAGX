{
  "desc_type": "module_emit",
  "name": "limit_shape_learner_v1",
  "code": "import os, json, time, collections\\nSRC = 'mem/cortex_lineage'\\nOUT = 'mem/limit_hyp'\\n\\ndef _load_last(n=6):\\n    if not os.path.exists(SRC): return []\\n    files = sorted([f for f in os.listdir(SRC) if f.endswith('.json')])[-n:]\\n    snaps = []\\n    for fn in files:\\n        with open(os.path.join(SRC, fn), 'r', encoding='utf-8') as f: snaps.append(json.load(f))\\n    return snaps\\n\\ndef _module_multiset(snap):\\n    # on ne garde que les noms racine pour voir ce qui revient toujours\\n    base = []\\n    for m in snap.get('modules', []):\\n        name = m.get('file','')\\n        root = name.split('_cortex_v')[0].split('.')[0]\\n        base.append(root)\\n    return base\\n\\ndef run(ctx=None):\\n    snaps = _load_last(8)\\n    if len(snaps) < 3:\\n        return {'desc_type':'limit_shape_idle'}\\n    # 1) compter la fréquence d'apparition des familles de modules\\n    freq = collections.Counter()\\n    for s in snaps:\\n        for r in _module_multiset(s):\\n            freq[r] += 1\\n    # 2) considérer comme \"noyau\" ce qui est présent dans >= 70% des derniers snaps\\n    k = [m for m,c in freq.items() if c >= int(len(snaps)*0.7)]\\n    # 3) regarder ce qui CROÎT (nouveaux plans ajoutés au fil du temps)\\n    seen_sets = [set(_module_multiset(s)) for s in snaps]\\n    growing = []\\n    for i in range(1, len(seen_sets)):\\n        add = seen_sets[i] - seen_sets[i-1]\\n        for a in add: growing.append(a)\\n    hyp = {\\n        'desc_type': 'limit_shape_hypothesis',\\n        'ts': time.time(),\\n        'core_modules': k,\\n        'monotonic_additions': list(sorted(set(growing))),\\n        'note': 'approximation de la forme qui se stabilise',\\n    }\\n    os.makedirs(OUT, exist_ok=True)\\n    name = f'limit_{int(time.time()*1000)}.json'\\n    with open(os.path.join(OUT, name), 'w', encoding='utf-8') as f: json.dump(hyp, f, ensure_ascii=False, indent=2)\\n    return {'desc_type':'limit_shape_inferred','file':name,'core':k,'growing':list(sorted(set(growing)))}\\n"
}
