{
  "desc_type": "module_emit",
  "name": "spec_gap_analyzer_v1",
  "code": "import os, json, time\\nSPEC_DIR = 'mem/spec_model'\\nHIST_DIR = 'mem/cortex_history'\\nOUT = 'mem/spec_gaps'\\n\\ndef _load_last_spec():\\n    if not os.path.exists(SPEC_DIR): return None\\n    files = sorted([f for f in os.listdir(SPEC_DIR) if f.endswith('.json')])\\n    if not files: return None\\n    with open(os.path.join(SPEC_DIR, files[-1]), 'r', encoding='utf-8') as f: return json.load(f)\\n\\ndef _estimate_current_capabilities():\\n    # approximation : on regarde ce qu'on a déjà rebuildé/émis\\n    caps = {\\n        'self_evo': 0.7,   # on a déjà le cycle snapshot/mutate/test\\n        'host_model': 0.6,  # on a le forward model\\n        'structural_search': 0.5, # on explore plusieurs candidats\\n        'goal_alignment': 0.3,    # faible : c'est là que ton hôte dit 'loin'\\n        'math_depth': 0.4,        # sauf si tu as beaucoup de research_task\\n        'safety_surface': 0.5,    # moyen\\n    }\\n    return caps\\n\\ndef run(ctx=None):\\n    os.makedirs(OUT, exist_ok=True)\\n    spec = _load_last_spec()\\n    if not spec: return {'desc_type':'spec_gap_idle'}\\n    target = spec.get('scores', {})\\n    cur = _estimate_current_capabilities()\\n    gaps = []\\n    for k, tgt in target.items():\\n        curv = cur.get(k, 0.0)\\n        gap = round(tgt - curv, 3)\\n        if gap > 0.15:  # manque réel\\n            gaps.append({'axis': k, 'target': tgt, 'current': curv, 'gap': gap})\\n    name = f'gaps_{int(time.time()*1000)}.json'\\n    with open(os.path.join(OUT, name), 'w', encoding='utf-8') as f:\\n        json.dump({'ts': time.time(), 'gaps': gaps}, f, ensure_ascii=False, indent=2)\\n    return {'desc_type':'host_spec_gaps_computed','file':name,'count':len(gaps)}\\n"
}
